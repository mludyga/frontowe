import { round2, sum } from "./math";

export type GateLayout = { panels: number[]; gaps: number[]; error?: string };
export type GateType = "none" | "skrzydłowa" | "przesuwna";

/**
 * Oblicza układ bramy/furtki (panele + przerwy) dla zadanej wysokości
 * z uwzględnieniem stałej ramy (frameVert) na górze i dole.
 *
 * Zasady:
 * - przerwa górna = topGap (zaokrąglana do 0.01 mm),
 * - środkowe przerwy = baseMidGaps (po 0.01 mm),
 * - po panelach bazowych opcjonalnie przerwa extraGapAfterBase i panele dodatkowe
 *   oddzielone extraBetweenGap (wszystko po 0.01 mm),
 * - ostatnia przerwa to „reszta” do wewnętrznej wysokości (też 0.01 mm).
 */
export function computeGateLayout(
  height: number,
  frameVert: number,
  basePanels: number[],
  baseMidGaps: number[],
  topGap: number,
  extraPanels: number[],
  extraGapAfterBase: number,
  extraBetweenGap: number
): GateLayout {
  if (basePanels.length === 0) return { panels: [], gaps: [] };

  const internal = Math.max(0, height - 2 * frameVert);
  const combinedPanels = [...basePanels, ...extraPanels];
  const gaps: number[] = [];

  gaps.push(round2(topGap));
  gaps.push(...baseMidGaps.map(round2));

  if (extraPanels.length > 0) {
    gaps.push(round2(Math.max(0, extraGapAfterBase)));
    for (let i = 1; i < extraPanels.length; i++) {
      gaps.push(round2(Math.max(0, extraBetweenGap)));
    }
  }

  const used = sum(basePanels) + sum(extraPanels) + sum(gaps);
  const leftover = internal - used;
  if (leftover < -0.001) {
    return {
      panels: combinedPanels,
      gaps,
      error: "Za mała wysokość bramy/furtki dla wybranego układu",
    };
  }

  gaps.push(round2(leftover));

  // drobna korekta ostatniej przerwy (gromadzenie błędu zaokrągleń)
  const corr = internal - (sum(basePanels) + sum(extraPanels)) - sum(gaps);
  if (Math.abs(corr) >= 0.5) {
    gaps[gaps.length - 1] = round2(gaps[gaps.length - 1] + corr);
  }

  return { panels: combinedPanels, gaps };
}

/**
 * Zwraca pozycje pionowych wzmocnień dla BRAMY PRZESUWNEJ.
 * Pozycje są X-lewe (mm) względem lewej krawędzi zewnętrznej.
 * Dla skrzydłowej i braku bramy -> [].
 */
export function getVerticalBars(
  gateType: GateType,
  gateWidth: number,
  frameVert: number
): number[] {
  if (gateType !== "przesuwna") return [];
  const f = frameVert;
  const innerW = Math.max(0, gateWidth - 2 * f);
  if (innerW <= 0) return [];
  if (gateWidth < 5000) {
    // jedno wzmocnienie na środku
    return [f + innerW / 2 - f / 2];
  }
  // ≥ 5 m: dwa wzmocnienia w ~1/3 i ~2/3
  return [f + innerW / 3 - f / 2, f + (2 * innerW) / 3 - f / 2];
}

/**
 * Liczy X-y krótkich wsporników w „przestrzeni 2”.
 * Bazowe kotwy: lewy i prawy bok ramy; dla przesuwnej także pionowe wzmocnienia,
 * dla skrzydłowej – dwa „boki” w miejscu styku skrzydeł.
 * Następnie w każdej przerwie można dołożyć równomiernie N dodatkowych wsporników.
 *
 * Zwraca tablicę X-lewych (mm) posortowaną rosnąco, bez duplikatów.
 */
export function computeBottomSupportXs(params: {
  gateType: GateType;
  gateWidth: number;
  frameVert: number;
  verticalBars?: number[];
  extraPerSpan: number; // ile dodatkowych w każdej przerwie
}): number[] {
  const { gateType, gateWidth, frameVert, verticalBars = [], extraPerSpan } =
    params;

  if (gateType === "none") return [];

  const f = frameVert;
  const anchors: number[] = [];

  // lewy/prawy bok ramy
  anchors.push(0);
  anchors.push(gateWidth - f);

  if (gateType === "przesuwna") {
    anchors.push(...verticalBars); // to są x-lewe
  } else if (gateType === "skrzydłowa") {
    // dwa „boki ramy” na styku skrzydeł
    anchors.push(gateWidth / 2 - f, gateWidth / 2);
  }

  // unikalne i posortowane
  const uniq = Array.from(new Set(anchors.map((a) => +a.toFixed(3)))).sort(
    (a, b) => a - b
  );

  const out: number[] = [...uniq];

  if (extraPerSpan > 0) {
    for (let i = 0; i < uniq.length - 1; i++) {
      const a = uniq[i];
      const b = uniq[i + 1];
      for (let k = 1; k <= extraPerSpan; k++) {
        const center = a + ((b - a) * k) / (extraPerSpan + 1);
        out.push(center - f / 2); // x-left tak, by wspornik był wycentrowany
      }
    }
  }

  return out.sort((a, b) => a - b);
}
